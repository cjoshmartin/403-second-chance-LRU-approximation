**Course**: ECE 408 (Operating Systems)

**Name**: Josh Martin

**HMW**: 5

**Date**: 04/11/2019

<!--NOTE: TLB <=> Translation look-aside buffer-->

Introduction
============

<!--Describe the objective of the homework. Summarize the results and the challenges.-->

This project consists of writing a program that translates logical addresses to physical addresses, for a virtual address space $2^{16}$. My program reads from a file containing logical addresses and, using a TLB as well as a page table, will translate each logical address to its corresponding physical address and output the value of the byte stored at the translated physical address. The goal behind this project is to simulate the steps involved in translating logical to physical addresses. This project assumes that the physical memory is the same size as the virtual address space.

Methodology
===========

<!--Describe your approach, include screenshots as needed. Code can be included here or in the Appendix. In the latter case, you may want to highlight the important part of your code here -->

The program reads a file containing several 32-bit integer numbers that represent logical addresses. However, It is only important to consist rightmost 16-bits. This 16-bits is divided into:

1. 8-bits page number
2. 8-bit page offset

## Address Structure

![](imgs/image_1.png)

* Physical Memory is broken into fixed-sized blocks called frame
* Logical memory is broken into blocks of equal size blocks called pages. 
* Every address generated by the CPU is divided into two parts: 
    - Page Number, used to index into the page table
    - Page Offset

* $2^8$ entries in page table 
* Page size of $2^8$ bytes 
* 16 entries in the TLB 
* Frame size of $2^8$ bytes 
* 256 frames
* Physical memory of $2^{16}$



```c
#define FRAME_SIZE 256
#define TOTAL_NUMBER_OF_FRAMES 128
#define TLB_SIZE 16
#define PAGE_TABLE_SIZE 256
#define ADDRESS_BUFFER_SIZE  10

typedef struct {
    int frame_number;
    int reference_bit;
}Page_table_item;

typedef struct {
    int pageNumber;
    int frameNumber;
} Translation_Lookaside_Buffer;

typedef struct TLB_data {
int hits;//counts TLB hits
    int entries;//counts the number of entries in the TLB
} TLB_data;

typedef struct data_struct {
    FILE *address_file;
    FILE *backing_store;
    TLB_data TLB;
    int faults;// counts page faults

    Page_table_item pageTable[PAGE_TABLE_SIZE];
    Translation_Lookaside_Buffer TLB_table[TLB_SIZE];
    int frame_table[TOTAL_NUMBER_OF_FRAMES]; // TODO: Change name
    signed char physicalMemory[TOTAL_NUMBER_OF_FRAMES][FRAME_SIZE];
    int firstAvailableFrame; //tracks the first available frame
    int firstAvailablePageTableNumber; //tracks the first available page table entry
} memory;

```

### Creation of Addresses 

Address are read in from the `address.txt` file into the address array. Which then gets converted into an integer then used in the `getPage` to create the TLB entry. 

The program will keep cycling through addresses until `address.txt` is empty.

```c
# main()
# ... 
    char address[ADDRESS_BUFFER_SIZE];
# .. 
    _this->address_file = openFile(argv[1], "r");

    while (fgets(address, ADDRESS_BUFFER_SIZE, _this->address_file) != NULL ) {
        getPage(_this, atoi(address)); // get the physical address and value
        addresses_seen++;  // increment the number of translated addresses
    }

    fclose(_this->address_file);
```

## Address Translation 

If the page number is not in the TLB, then a TLB miss happens. The memory reference to the page table must be made. When the frame number is obtained, it is now possible to access memory. In the next access, this chunk of memory will be more easily accessible by the use of it's page number and frame number in the TLB. 

![](imgs/image_2.png)

### Creating the Page Number and Offset

In `getPage` the logical address are read in as 32bit address. To get the Page number, we logical AND the logical address with `0xFF00` to ignore the last 8-bits and to get the correct Page number, we need to shift everything to the right by 1 byte. To obtain the Offset we will apply logical AND with `0x00FF` such that it will discard the left most byte.

```c
# getPage( virtual_memory * _this, int logical_address)

    int pageNumber = ((logical_address & 0xFF00)>>8); // 8-bit page number
    int offset = (logical_address & 0x00FF); // 8-bit page offset

```

### Determining the frame number

```c

# getPage( virtual_memory * _this, int logical_address)
    int frame_number = find_frame(_this, pageNumber);
```

If the Page number is in the TLB, set current index's TLB's frame number to the `frame_number` and increment `TlB.hits` for statical purpose.
```c
int second_chance(memory * _this, int frame_number, int pageNumber){
    if(_this->frame_table[frame_number] != -1 ){

        int checkRefBit = _this->frame_table[frame_number];
        while (_this->pageTable[checkRefBit].reference_bit){ // while there is no one to pray on Mahaha
            _this->pageTable[checkRefBit].reference_bit = 0;

            frame_number = updateFramePointer(_this,frame_number);
            checkRefBit = _this->frame_table[checkRefBit];
        }

        // Evict from the LRU
        for (int i = 0; i < TLB_SIZE ; ++i)
            if(_this->TLB_table[i].pageNumber == checkRefBit)
                _this->TLB_table[i].pageNumber = -1;

        _this->pageTable[checkRefBit].frame_number = -1;
        _this->pageTable[checkRefBit].reference_bit = 0;
    }

    _this->frame_table[frame_number] = pageNumber;

    getStore(_this, pageNumber, frame_number); // gets data from .bin
    _this->pageTable[pageNumber].frame_number = -1;
    _this->pageTable->reference_bit = 0;

    return frame_number;

}

int find_frame(memory * _this, int pageNumber){
    int i,
    frame_number = - 1;

    for(i = 0; i < TLB_SIZE; i++){
        if(_this->TLB_table[i].pageNumber == pageNumber){
            frame_number = _this->TLB_table[i].frameNumber;
            _this->TLB.hits++;

            _this->pageTable[i].reference_bit = 1;
        }
    }

    if(frame_number == -1){ // frame_number not found
        frame_number = _this->pageTable[pageNumber].frame_number;

        if(frame_number == -1){// the page is not found in those contents
            _this->faults++;

            frame_number = updateFramePointer(_this, frame_number);
            frame_number= second_chance(_this, frame_number, pageNumber);


        }
        else{
            _this->pageTable[pageNumber].reference_bit = 1;

            _this->TLB_table[_this->firstAvailablePageTableNumber].frameNumber = frame_number;
            _this->TLB_table[_this->firstAvailablePageTableNumber].pageNumber = pageNumber;

            _this->firstAvailablePageTableNumber++;
            _this->firstAvailablePageTableNumber %= TLB_SIZE;

        }
    }
    return frame_number;
}

```


The disk space data is represented by the file `BACKING_STORE.bin`. When a page fault occurs, the program reads a 256 byte chuck from the BACKING STORE and stores it to an available space in memory. The `BACKING_STORE.bin` is treated as random access.

```c
#define BUFFER_SIZE  256 // number of bytes to read

#getStore(virtual_memory *_this, int pageNumber)

    signed char buffer[BUFFER_SIZE];

    if (fseek(_this->backing_store, pageNumber * BUFFER_SIZE, SEEK_SET) != 0) {
        fprintf(stderr, "Error seeking in backing store\n");
    }

    // now read BUFFER_SIZE bytes from the backing store to the buffer
    if (fread(buffer, sizeof(signed char), BUFFER_SIZE, _this->backing_store) == 0) {
        fprintf(stderr, "Error reading from backing store\n");
    }

    // load the bits into the first available frame in the physical memory 2D array
    for(int i = 0; i < BUFFER_SIZE; i++){
        _this->physicalMemory[_this->firstAvailableFrame][i] = buffer[i];
    }

    // load the frame number into the page table in the first available frame
    _this->pager.TableNumbers[_this->firstAvailablePageTableNumber] 
    = pageNumber;

    _this->pager.TableFrames[_this->firstAvailablePageTableNumber]
    = _this->firstAvailableFrame;

    //track the next available frames
    _this->firstAvailableFrame++;
    _this->firstAvailablePageTableNumber++;
```

### Creating TLB and FIFO page replacement

Since we now have the `pageNumber` and `frame_number`, we can now queue TLB to assert if an entry exist. If not, we can create a new one into the TLB.

```c
# getPage( virtual_memory * _this, int logical_address)
    setIntoTLB(_this, pageNumber, frame_number);
```

We first check if an entry exist in the TLB
```c
# setIntoTLB(virtual_memory *_this, int pageNumber, int frameNumber)
    FIFO_algorthim(_this, pageNumber, frameNumber);

    if(_this->TLB.entries < TLB_SIZE){
        _this->TLB.entries++;
    }
    }
```

If `i == _this->TLB.entries` then means an entry exist in the TLB. We then need to check if the TLB is full. If the TLB is not full then we can insert at the end of the TLB. Otherwise, we will data out of the TLB and insert our new data.

```
void FIFO_algorthim(memory *_this, int pageNumber, int frameNumber) {

    int i;  // if it's already in the TLB, break
    for(i = 0; i < _this->TLB.entries; i++){
        if(_this->TLB_table[i].pageNumber == pageNumber){
            break;
        }
    }

    if(i == _this->TLB.entries){
        if(_this->TLB.entries < TLB_SIZE){
            // insert the page and frame on the end
            _this->TLB_table[_this->TLB.entries].pageNumber = pageNumber;
            _this->TLB_table[_this->TLB.entries].frameNumber = frameNumber;
        }
        else{// otherwise shift everything
            for(i = 0; i < TLB_SIZE - 1; i++){
                _this->TLB_table[i].pageNumber = _this->TLB_table[i + 1].pageNumber;
                _this->TLB_table[i].frameNumber = _this->TLB_table[i +1].frameNumber;
            }
            _this->TLB_table[_this->TLB.entries-1].pageNumber = pageNumber;
            _this->TLB_table[_this->TLB.entries -1 ].frameNumber = frameNumber;
        }
    }
    else{ // index is not <==> to # of entries
        for(; i < _this->TLB.entries - 1; i++){
            _this->TLB_table[i].pageNumber = _this->TLB_table[i+1].pageNumber;
            _this->TLB_table[i].frameNumber = _this->TLB_table[i+1].frameNumber;
        }
    }
}

```

This process above and below is a FIFO page replacement. FIFO page replacement is simplest page replacement algorithm replacing based on when each page was enter into the TLB and replacing the oldest page if the TLB is full.

If entry exist but not at the end of the TLB then we shift everything from the current index forward.
```c
    else{ // index is not <==> to # of entries
        for(; i < _this->TLB.entries - 1; i++){
            _this->TLB.pageNumber[i] = _this->TLB.pageNumber[i + 1];
            _this->TLB.frameNumber[i] = _this->TLB.frameNumber[i + 1];
        }
        if(_this->TLB.entries < TLB_SIZE){// if there is room, put @ end
            _this->TLB.pageNumber[_this->TLB.entries] = pageNumber;
            _this->TLB.frameNumber[_this->TLB.entries] = frameNumber;
        }
        else{// put the page and frame @  (entries - 1)
            _this->TLB.pageNumber[_this->TLB.entries-1] = pageNumber;
            _this->TLB.frameNumber[_this->TLB.entries-1] = frameNumber;
        }
    }
```

We need to indicate that new entry has been added, until all frames in TLB have been allocated beforehand.

```c
    if(_this->TLB.entries < TLB_SIZE){
        _this->TLB.entries++;
    }
```

### Determining Physical Address

After visiting the `find_frame`, we now have enough to calculate the physical address. Then we can print the logical address, physical address, and the value at  `physicalMemory[frame_number][offset]`

```c
# getPage( virtual_memory * _this, int logical_address)
    physical_address = (frame_number << 8) | offset;
```

## Statistics

 After completion, the program will report stats on:

 1. Page-Fault rate
 2. TLB hit rate

```c
void print_stats(virtual_memory * _this, double total_addresses){

    // calculate and print out the stats
    printf("Number of translated addresses = %.0f\n", total_addresses);

    printf("Page Miss Rate: %.3f\n",_this->pager.faults / total_addresses);
    printf("TLB Hit Rate: %.3f\n", _this->TLB.hits / total_addresses);

}

```

Results
=======

<!--Include the results in details, showing executing steps (snapshots) for each component of your homework. You also need to provide an analysis of your results. What worked and what did not and why ?-->

## Output 

```bash
Number of translated addresses = 1000
Page Miss Rate: 0.244
TLB Hit Rate: 0.055
```


Summary
=======

<!--Include your conclusions. What did you learn? How would you improve on your approach?-->

I think this was a great program. It was interesting dealing with the challenges of creating an virtual memory manager. This program has thought me a lot of about paging, physical memory, translation look-aside buffer, address management. I had a hard time wrapping my head around how the TLB works and finding if the frame number existed.

Appendix
========

<!--You may include sections of your code here that you would want to refer to in the report. However, you still need to submit your code in a complete package that can be compiled, executed and verified. You will also need to provide any input files that you used to execute your application-->

---


